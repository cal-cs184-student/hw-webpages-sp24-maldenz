<html>
   <head>
      <meta content="text/html; charset=UTF-8" http-equiv="content-type">
      <style type="text/css">ol.lst-kix_m2fr1j50pk9-0{list-style-type:none}.lst-kix_m2fr1j50pk9-3>li{counter-increment:lst-ctn-kix_m2fr1j50pk9-3}ol.lst-kix_m2fr1j50pk9-1{list-style-type:none}.lst-kix_m2fr1j50pk9-0>li{counter-increment:lst-ctn-kix_m2fr1j50pk9-0}ol.lst-kix_m2fr1j50pk9-2.start{counter-reset:lst-ctn-kix_m2fr1j50pk9-2 0}ol.lst-kix_m2fr1j50pk9-6{list-style-type:none}.lst-kix_m2fr1j50pk9-6>li:before{content:"" counter(lst-ctn-kix_m2fr1j50pk9-6,decimal) ". "}ol.lst-kix_m2fr1j50pk9-7{list-style-type:none}ol.lst-kix_m2fr1j50pk9-8{list-style-type:none}ol.lst-kix_m2fr1j50pk9-2{list-style-type:none}.lst-kix_m2fr1j50pk9-8>li:before{content:"" counter(lst-ctn-kix_m2fr1j50pk9-8,lower-roman) ". "}ol.lst-kix_m2fr1j50pk9-3{list-style-type:none}ol.lst-kix_m2fr1j50pk9-4{list-style-type:none}.lst-kix_m2fr1j50pk9-7>li:before{content:"" counter(lst-ctn-kix_m2fr1j50pk9-7,lower-latin) ". "}ol.lst-kix_m2fr1j50pk9-5{list-style-type:none}ol.lst-kix_m2fr1j50pk9-6.start{counter-reset:lst-ctn-kix_m2fr1j50pk9-6 0}ol.lst-kix_m2fr1j50pk9-5.start{counter-reset:lst-ctn-kix_m2fr1j50pk9-5 0}ol.lst-kix_m2fr1j50pk9-0.start{counter-reset:lst-ctn-kix_m2fr1j50pk9-0 0}ol.lst-kix_m2fr1j50pk9-8.start{counter-reset:lst-ctn-kix_m2fr1j50pk9-8 0}.lst-kix_m2fr1j50pk9-6>li{counter-increment:lst-ctn-kix_m2fr1j50pk9-6}ol.lst-kix_m2fr1j50pk9-3.start{counter-reset:lst-ctn-kix_m2fr1j50pk9-3 0}ol.lst-kix_m2fr1j50pk9-1.start{counter-reset:lst-ctn-kix_m2fr1j50pk9-1 0}.lst-kix_m2fr1j50pk9-2>li{counter-increment:lst-ctn-kix_m2fr1j50pk9-2}.lst-kix_m2fr1j50pk9-5>li{counter-increment:lst-ctn-kix_m2fr1j50pk9-5}.lst-kix_m2fr1j50pk9-7>li{counter-increment:lst-ctn-kix_m2fr1j50pk9-7}.lst-kix_m2fr1j50pk9-0>li:before{content:"" counter(lst-ctn-kix_m2fr1j50pk9-0,decimal) ". "}.lst-kix_m2fr1j50pk9-2>li:before{content:"" counter(lst-ctn-kix_m2fr1j50pk9-2,lower-roman) ". "}.lst-kix_m2fr1j50pk9-3>li:before{content:"" counter(lst-ctn-kix_m2fr1j50pk9-3,decimal) ". "}.lst-kix_m2fr1j50pk9-1>li{counter-increment:lst-ctn-kix_m2fr1j50pk9-1}.lst-kix_m2fr1j50pk9-4>li{counter-increment:lst-ctn-kix_m2fr1j50pk9-4}.lst-kix_m2fr1j50pk9-1>li:before{content:"" counter(lst-ctn-kix_m2fr1j50pk9-1,lower-latin) ". "}.lst-kix_m2fr1j50pk9-5>li:before{content:"" counter(lst-ctn-kix_m2fr1j50pk9-5,lower-roman) ". "}.lst-kix_m2fr1j50pk9-8>li{counter-increment:lst-ctn-kix_m2fr1j50pk9-8}ol.lst-kix_m2fr1j50pk9-7.start{counter-reset:lst-ctn-kix_m2fr1j50pk9-7 0}ol.lst-kix_m2fr1j50pk9-4.start{counter-reset:lst-ctn-kix_m2fr1j50pk9-4 0}.lst-kix_m2fr1j50pk9-4>li:before{content:"" counter(lst-ctn-kix_m2fr1j50pk9-4,lower-latin) ". "}ol{margin:0;padding:0}table td,table th{padding:0}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c0{font-size:12pt;font-family:"Times New Roman";font-style:italic;color:#080a0d;font-weight:400}.c6{color:#080a0d;font-weight:700;font-size:12pt;font-family:"Times New Roman"}.c11{-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline;text-decoration-skip-ink:none}.c1{font-size:12pt;font-family:"Times New Roman";color:#080a0d;font-weight:400}.c7{font-size:12pt;font-family:"Times New Roman";font-weight:400}.c13{font-weight:700;font-size:12pt;font-family:"Times New Roman"}.c10{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c2{text-decoration:none;vertical-align:baseline;font-style:normal}.c12{color:inherit;text-decoration:inherit}.c4{margin-left:36pt;height:11pt}.c8{color:#000000}.c5{height:11pt}.c9{color:#333333}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style>
   </head>
   <body class="c10 doc-content">
      <p class="c3"><span class="c2 c8 c13">Compsci 184 Hw2</span></p>
      <p class="c3"><span class="c7 c2 c8">Haoqing Xuan 3036149505</span></p>
      <p class="c3"><span class="c7 c2 c8">Maodun Zhang 3035626112</span></p>
      <hr style="page-break-before:always;display:none;">
      <p class="c3 c5"><span class="c7 c2 c8"></span></p>
      <p class="c3"><span class="c13 c2 c8">Part 1</span></p>
      <p class="c3"><span class="c7">To my understanding, </span><span class="c7 c9">de Casteljau&#39;s algorithm</span><span class="c1 c2">&nbsp;works by linearly interpolating between the control points of the B&eacute;zier curve, progressively creating new sets of points that are closer to the actual curve. Therefore, I created my set of 6 control points and then applied the evaluateStep function.</span></p>
      <p class="c3 c5"><span class="c1 c2"></span></p>
      <p class="c3"><span class="c1 c2">6 control points snapshot</span></p>
      <p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.00px; height: 213.16px;"><img alt="" src="images/image7.png" style="width: 307.00px; height: 222.00px; margin-left: 0.00px; margin-top: -8.84px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.00px; height: 214.16px;"><img alt="" src="images/image19.png" style="width: 307.00px; height: 221.00px; margin-left: 0.00px; margin-top: -6.84px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
      <p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.00px; height: 207.38px;"><img alt="" src="images/image3.png" style="width: 307.00px; height: 221.00px; margin-left: 0.00px; margin-top: -13.62px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.00px; height: 206.62px;"><img alt="" src="images/image12.png" style="width: 307.00px; height: 230.82px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
      <p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.20px; height: 198.66px;"><img alt="" src="images/image8.png" style="width: 307.20px; height: 198.66px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span>
      <hr style="page-break-before:always;display:none;">
      </p>
      <p class="c3"><span class="c1">If I move the control point a little and change the </span><span class="c0">t</span><span class="c1 c2">&nbsp;a little, I get the following graph:</span></p>
      <p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 313.43px;"><img alt="" src="images/image9.png" style="width: 480.00px; height: 313.43px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
      <p class="c3 c4"><span class="c1 c2"></span></p>
      <hr style="page-break-before:always;display:none;">
      <p class="c3 c4"><span class="c1 c2"></span></p>
      <p class="c3"><span class="c6 c2">Part 2</span></p>
      <p class="c3"><span class="c1">The de Casteljau algorithm is a recursive method to evaluate Bezier curves at a given parameter </span><span class="c0">t</span><span class="c1">. This algorithm can be extended to Bezier surfaces by applying it in two dimensions, using two parameters </span><span class="c0">u</span><span class="c1">&nbsp;and </span><span class="c0">v</span><span class="c1 c2">.</span></p>
      <p class="c3"><span class="c1">For Bezier surfaces, which are defined by a grid of control points, the algorithm works as follows: Apply de Casteljau in one direction: Treat each row of control points as defining a Bezier curve. Apply the de Casteljau algorithm to each row with the parameter u to find the intermediate control points along each row. This results in a new set of control points that form a &quot;cross-section&quot; of the surface. Then apply de Casteljau in the orthogonal direction: use the new set of control points obtained from the first step as control points of Bezier curves running in the orthogonal direction. Apply the de Casteljau algorithm to these points with the parameter </span><span class="c0">v</span><span class="c1 c2">&nbsp;to evaluate the point on the surface at.</span></p>
      <p class="c3"><span class="c1">For our implementation, we implement the evaluateStep method for a Bezier surface by computing the intermediate control points for a given parameter </span><span class="c0">t</span><span class="c1 c2">. This will be similar to the evaluateStep method for Bezier curves, but will work with Vector3D points instead of Vector2D. And we then Implement the evaluate1D method to apply the de Casteljau algorithm recursively, using the evaluateStep method until we obtain a single point from a 1D Bezier curve. Finally, in the evaluate method, we use the evaluate1D method twice: once for all rows with parameter u to compute the new set of control points, and then again for these resulting points with parameter v to find the final point on the surface.</span></p>
      <p class="c3 c5"><span class="c1 c2"></span></p>
      <p class="c3"><span class="c1 c2">Snapshot</span></p>
      <p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 316.80px;"><img alt="" src="images/image1.png" style="width: 480.00px; height: 332.05px; margin-left: 0.00px; margin-top: -15.25px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span>
      <hr style="page-break-before:always;display:none;">
      </p>
      <p class="c3"><span class="c6">Part 3</span></p>
      <p class="c3"><span class="c1 c2">In our implementation, we initialize Normal Accumulator, which we begin by initializing a Vector3D object to act as an accumulator for the area-weighted normals and then iterate over all faces incident to the vertex.</span></p>
      <p class="c3"><span class="c1 c2">Then we calculate face normal by taking the cross product of two edges of the face. Since the cross product&#39;s magnitude is proportional to the parallelogram&#39;s area formed by the two vectors, and the triangle is half of this, the resulting vector is already area-weighted. Once all incident faces have been processed, we normalize the accumulated normal to turn it into a unit vector.</span></p>
      <p class="c3 c5"><span class="c1 c2"></span></p>
      <p class="c3"><span class="c1 c2">Snapshot </span></p>
      <p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 319.02px;"><img alt="" src="images/image15.png" style="width: 480.00px; height: 332.42px; margin-left: 0.00px; margin-top: -13.40px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
      <hr style="page-break-before:always;display:none;">
      <p class="c3 c5"><span class="c1 c2"></span></p>
      <p class="c3"><span class="c6 c2">Part 4</span></p>
      <p class="c3"><span class="c1 c2">The flipEdge implementation follows these steps:</span></p>
      <p class="c3"><span class="c1">Starts by checking if the edge </span><span class="c0">e0 </span><span class="c1 c2">is a boundary edge. If so, the function returns immediately, as flipping a boundary edge is now allowed.</span></p>
      <p class="c3"><span class="c1 c2">Gathers the halfedges, vertices, edges, and faces that are involved in the flip operation.</span></p>
      <p class="c3"><span class="c1">Uses the </span><span class="c0">setNeighbors</span><span class="c1 c2">&nbsp;method to reassign the &lsquo;next&rsquo;, &lsquo;twin&rsquo;, &lsquo;vertex&rsquo;, &lsquo;edge&rsquo;, and &lsquo;face&rsquo; points of the halfedges involved in the two triangles adjacent to the edge being flipped.</span></p>
      <p class="c3"><span class="c6 c2">Halfedges:</span></p>
      <p class="c3"><span class="c0">h0</span><span class="c1">&nbsp;and</span><span class="c0">&nbsp;h3</span><span class="c1">&nbsp;are the two halfedges of the edge being flipped (</span><span class="c0">e0</span><span class="c1">). Their vertex pointers are updated to point to the vertices that will be connected by the new edge (</span><span class="c0">v3</span><span class="c1">&nbsp;and </span><span class="c0">v2</span><span class="c1 c2">&nbsp;respectively).</span></p>
      <p class="c3"><span class="c0">h1</span><span class="c1">, </span><span class="c0">h2</span><span class="c1">, </span><span class="c0">h4</span><span class="c1">, and </span><span class="c0">h5</span><span class="c1">&nbsp;have their next pointers updated to point to the next </span><span class="c0">halfedge</span><span class="c1 c2">&nbsp;in their respective faces after the flip.</span></p>
      <p class="c3"><span class="c0">h6</span><span class="c1">, </span><span class="c0">h7</span><span class="c1">, </span><span class="c0">h8</span><span class="c1">, and </span><span class="c0">h9</span><span class="c1 c2">&nbsp;remain connected to their current faces but their twin pointers are updated to reflect the new connections.</span></p>
      <p class="c3"><span class="c6 c2">Vertices:</span></p>
      <p class="c3"><span class="c0">v0</span><span class="c1">, </span><span class="c0">v1</span><span class="c1">, </span><span class="c0">v2</span><span class="c1">, and </span><span class="c0">v3</span><span class="c1">&nbsp;now have their </span><span class="c0">halfedge</span><span class="c1 c2">&nbsp;pointers set to one of the halfedges emanating from them after the flip.</span></p>
      <p class="c3"><span class="c6 c2">Edges:</span></p>
      <p class="c3"><span class="c0">e0</span><span class="c1">&nbsp;is the flipped edge and it keeps one of its halfedges (</span><span class="c0">h0</span><span class="c1 c2">).</span></p>
      <p class="c3"><span class="c1">The other edges</span><span class="c0">&nbsp;e1</span><span class="c1">, </span><span class="c0">e2</span><span class="c1">, </span><span class="c0">e3</span><span class="c1">, and </span><span class="c0">e4</span><span class="c1">&nbsp;are not directly affected by the flip but their </span><span class="c0">halfedge</span><span class="c1 c2">&nbsp;pointers are updated to maintain consistency.</span></p>
      <p class="c3"><span class="c6 c2">Faces:</span></p>
      <p class="c3"><span class="c0">f0</span><span class="c1">&nbsp;and </span><span class="c0">f1</span><span class="c1">&nbsp;have their </span><span class="c0">halfedge</span><span class="c1">&nbsp;pointers updated to point to one of the </span><span class="c1">halfedges</span><span class="c1 c2">&nbsp;on their boundaries after the flip.</span></p>
      <p class="c3 c5"><span class="c1 c2"></span></p>
      <p class="c3"><span class="c1">After reassigning all the pointers, the function returns </span><span class="c0">e0</span><span class="c1 c2">, which now represents the flipped edge.</span></p>
      <p class="c3 c5"><span class="c1 c2"></span></p>
      <p class="c3"><span class="c1">This reassignment ensures that all the elements in the mesh remain consistently connected after the edge flip operation. It&#39;s important that all pointers are updated correctly to preserve the mesh&rsquo;s integrity, as any mistake in reassignment can corrupt the data structure and cause issues with future operations on the mesh.</span></p>
      <p class="c3"><span class="c1">Snapshot - edges on the middle of the pot body is rotated</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 319.02px;"><img alt="" src="images/image18.png" style="width: 480.00px; height: 334.26px; margin-left: 0.00px; margin-top: -15.25px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span>
      <hr style="page-break-before:always;display:none;">
      </p>
      <p class="c3"><span class="c2 c6">Part 5</span></p>
      <p class="c3"><span class="c1">The general logic of splitting edges follows these steps:</span></p>
      <p class="c3"><span class="c1">Creating a new vertex </span><span class="c0">v4</span><span class="c1">&nbsp;along the edge </span><span class="c0">e0</span><span class="c1 c2">.</span></p>
      <p class="c3"><span class="c1 c2">Creating new half-edges to maintain the structure of the half-edge mesh.</span></p>
      <p class="c3"><span class="c1 c2">Creating new edges and faces as necessary.</span></p>
      <p class="c3"><span class="c1">Reassigning the </span><span class="c0">next</span><span class="c1">, </span><span class="c0">twin</span><span class="c1">, </span><span class="c0">vertex</span><span class="c1">, </span><span class="c0">edge</span><span class="c1">, and </span><span class="c0">face</span><span class="c1 c2">&nbsp;pointers to reflect the updated mesh topology.</span></p>
      <p class="c3 c5"><span class="c1 c2"></span></p>
      <p class="c3"><span class="c1">We took this link for references in order to complete the method: </span><span class="c7 c11"><a class="c12" href="https://www.google.com/url?q=http://15462.courses.cs.cmu.edu/fall2015content/misc/HalfedgeEdgeOpImplementationGuide.pdf&amp;sa=D&amp;source=editors&amp;ust=1709194392056632&amp;usg=AOvVaw0-eGX8nlIgK1nLwtJooAzA">http://15462.courses.cs.cmu.edu/fall2015content/misc/HalfedgeEdgeOpImplementationGuide.pdf</a></span>
      <hr style="page-break-before:always;display:none;">
      </p>
      <p class="c3"><span class="c1 c2">Snapshot - after some edge splits</span></p>
      <p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 321.16px;"><img alt="" src="images/image10.png" style="width: 480.00px; height: 335.00px; margin-left: 0.00px; margin-top: -13.84px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
      <p class="c3"><span class="c1 c2">Snapshot - after some edge splits and edge flips</span></p>
      <p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 319.75px;"><img alt="" src="images/image16.png" style="width: 480.00px; height: 319.75px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
      <p class="c3 c5"><span class="c1 c2"></span></p>
      <hr style="page-break-before:always;display:none;">
      <p class="c3 c5"><span class="c1 c2"></span></p>
      <p class="c3"><span class="c6">Part 6:</span></p>
      <p class="c3"><span class="c1">We first iterate through all vertices in the mesh and calculated the weighted neighboring vertice positions, and then we following the equation </span><span class="c0">(1 - n * u) * original_position + u * original_neighbor_position_sum</span><span class="c1">&nbsp;to find the updated positions for each vertice. Then we update the new positions again with regard to the edges by iterating through all edges and determine whether they are part of the boundary. If not, we use the </span><span class="c0">3/8 * (A + B) + 1/8 * (C + D)</span><span class="c1 c2">&rdquo; equation to calculate the new positions. Then we iterate through all edges in the copied edge list and split all edges. Then we flip edges that connect only new and old vertices (blue edges). Finally we update the positions of all vertices. </span></p>
      <p class="c3 c5"><span class="c1 c2"></span></p>
      <p class="c3"><span class="c1 c2">As we can see from images below, loop subdivision will smooth all sharp corners and edges and make them more like curves. </span></p>
      <hr style="page-break-before:always;display:none;">
      <p class="c3 c5"><span class="c1 c2"></span></p>
      <p class="c3"><span class="c1 c2">Effect of loop subdivision to the Cube:</span></p>
      <p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.20px; height: 269.31px;"><img alt="" src="images/image4.png" style="width: 307.20px; height: 269.31px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.00px; height: 268.00px;"><img alt="" src="images/image13.png" style="width: 307.00px; height: 279.00px; margin-left: 0.00px; margin-top: -5.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.20px; height: 288.37px;"><img alt="" src="images/image17.png" style="width: 307.20px; height: 288.37px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.20px; height: 278.53px;"><img alt="" src="images/image11.png" style="width: 307.20px; height: 278.53px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 310.50px; height: 260.74px;"><img alt="" src="images/image20.png" style="width: 310.50px; height: 260.74px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span>
      <hr style="page-break-before:always;display:none;">
      </p>
      <p class="c3"><span class="c1 c2">Effect of pre-splitting: </span></p>
      <p class="c3"><span class="c1 c2">As we can see from comparison of images below to images above, when we pre-split some edges at sharp corners, we can reduce the effect of loop subdivision and maintain some sharpness in the graph. And the more splitting we do, the more sharpness will be maintained. </span></p>
      <p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.20px; height: 273.41px;"><img alt="" src="images/image14.png" style="width: 307.20px; height: 273.41px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.20px; height: 237.57px;"><img alt="" src="images/image5.png" style="width: 307.20px; height: 237.57px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.20px; height: 269.31px;"><img alt="" src="images/image6.png" style="width: 307.20px; height: 269.31px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.20px; height: 283.65px;"><img alt="" src="images/image2.png" style="width: 307.20px; height: 283.65px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
   </body>
</html>
