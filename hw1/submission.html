<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c8{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c4{background-color:#ffffff;color:#0d0d0d;text-decoration:none;vertical-align:baseline;font-style:normal}.c6{text-decoration:none;vertical-align:baseline;font-style:italic}.c9{font-weight:700;font-size:12pt;font-family:"Times New Roman"}.c12{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c2{font-size:12pt;font-family:"Times New Roman";font-weight:400}.c5{background-color:#ffffff;color:#333333}.c10{background-color:#ffffff;color:#0d0d0d}.c7{color:#333333}.c3{height:11pt}.c11{font-style:italic}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c12 doc-content"><p class="c0"><span class="c8">Compsci 184 hw01</span></p><p class="c0"><span class="c1">Maodun Zhang 3035626112</span></p><p class="c0"><span class="c2">Haoqing Xuan 3036149505</span><hr style="page-break-before:always;display:none;"></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c8">Part 1</span></p><p class="c0"><span class="c8">Rasterization Process:</span></p><p class="c0"><span class="c1">Bounding Box Calculation: The code first calculates the bounding box of the triangle. This is done by finding the minimum and maximum x and y values among the three vertices. This bounding box represents the smallest rectangle that completely contains the triangle.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Iterating Over the Bounding Box: The code then iterates over every pixel inside this bounding box. The iteration starts from the minimum x and y values and goes up to the maximum values. For each pixel, the code checks if it lies inside the actual triangle.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Orientation Check (Clockwise or Counter-Clockwise): The code calculates whether the triangle is oriented clockwise or counter-clockwise. This is determined using a cross product formula. The sign of this calculation tells us the orientation.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Point Inside Triangle Check: For each pixel, the code checks if it&#39;s inside the triangle. This is done using a method called the &quot;line equation test&quot; (lecture 2). The code performs this test differently based on the orientation of the triangle (clockwise or counter-clockwise). Essentially, it checks on which side of each edge of the triangle the point lies. If the point is on the &quot;inside&quot; side for all edges, it is inside the triangle.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Filling the Pixel: If a pixel is found to be inside the triangle, it would typically be colored (or &quot;filled&quot;) with the given color. In this code, the actual filling part is commented out (// fill_pixel(floor(x), floor(y), color);).</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c8">Efficiency:</span></p><p class="c0"><span class="c2">The naive approach would check every sample point in the bounding box to see if it lies inside the triangle, which this algorithm also does. However, the efficiency of the provided algorithm lies in its simplicity and the directness of the inside-triangle check. The area-based method used here is a straightforward linear equation, which tends to be faster to compute compared to other methods.</span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c6 c2 c7"></span></p><p class="c0"><span class="c6 c2 c7">basic/test4.svg</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image5.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c8">Part 2</span></p><p class="c0"><span class="c8">Why supersampling is useful:</span></p><p class="c0"><span class="c1">Reducing Aliasing: Supersampling helps in smoothing out the edges of shapes by averaging color values over multiple samples within each pixel. This creates a more natural and less pixelated image.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Improved Image Quality: By taking multiple samples within each pixel, the algorithm captures more detail and color variance, leading to higher-quality images.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Better Representation of Shapes: For geometric shapes like triangles, supersampling ensures that the edges are smoother and more closely represent the intended shape.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Modifications to the rasterization pipeline:</span></p><p class="c0"><span class="c1">Increased Number of Samples per Pixel: The rasterizer now samples multiple points within a single pixel, as opposed to one sample per pixel in basic rasterization. The number of samples per pixel is determined by sample_rate.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Modified Buffer Size: The sample buffer size is increased to accommodate the additional samples. The buffer size is now proportional to the square of the sample rate times the original image size.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Adapted Fill Algorithm: The algorithm for determining if a point is inside the triangle is adapted to work with sub-pixel samples.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c8">Implementation of supersampling:</span></p><p class="c0"><span class="c1">Sample Rate Determination: The sample rate determines how many samples are taken per pixel. It&#39;s given by sqrt(this-&gt;sample_rate) * sqrt(this-&gt;sample_rate). This suggests that the sample rate is the square of an integer, ensuring a uniform grid of samples in each pixel.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Step Size Calculation: The step size, which is the distance between sample points, is calculated as 1/sqrt(this-&gt;sample_rate). This determines how densely the algorithm samples within each pixel area.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Loop Through Samples: The algorithm iterates over the sample points determined by the step size within the bounding box of the triangle (calculated using floor and ceil of the minimum and maximum x and y coordinates of the triangle vertices).</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Inside Triangle Check for Each Sample: For each sample point, the algorithm checks whether the point is inside the triangle. This is done using a method that determines the orientation of the triangle (clockwise or counter-clockwise) and then checks if the point lies within all three sides of the triangle.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Color Assignment: If a sample point is inside the triangle, the corresponding color is assigned to that sample in the sample buffer.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Buffer Index Calculation: The buffer index for each sample is calculated taking into account the increased buffer size due to supersampling.</span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c6 c2 c7"></span></p><p class="c0"><span class="c6 c2 c7">basic/test4.svg</span></p><p class="c0"><span class="c2">sample rate = 1</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image1.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c0"><span class="c6 c2 c7">basic/test4.svg</span></p><p class="c0"><span class="c2">sample rate = 4</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image9.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c2"><br></span><hr style="page-break-before:always;display:none;"></p><p class="c0"><span class="c6 c2 c7">basic/test4.svg</span></p><p class="c0"><span class="c2">sample rate = 16</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image14.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c8">Supersampling explanation:</span></p><p class="c0"><span class="c1">As the sampling rate increases, more sample points are used to determine the color of each pixel. For example, with a 4x supersampling rate, each pixel will be divided into 4 samples (2x2 grid), and with a 16x rate, each pixel will be divided into 16 samples (4x4 grid).</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c2">When the samples within a pixel cover both the inside and the outside of a triangle, the final color of the pixel will be a blend of the triangle&#39;s color and the background color. The more samples you have, the more accurate this blending will be, which softens the edge visually and reduces the appearance of aliasing.</span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c8">Part 3</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image8.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1">I added a few more blocks onto the cubeman so that now it looks like a standing boxer with giant fists and strong arms. I changed the rotation and scaling of the original arms so that now they point upward and created the shoulder and armor of the robot. I added more blocks around the body of the robot and edited the transform so that it also becomes the armor of the robot. </span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c8">Part 4</span></p><p class="c0"><span class="c4 c2">Barycentric coordinates are a way of representing points within a triangle using the concept of weights or influences of the triangle&#39;s vertices. Essentially, any point inside a triangle can be described based on how much it is &quot;influenced&quot; by each of the triangle&#39;s three vertices.</span></p><p class="c0"><span class="c2 c5 c11">svg/basic/colored_triangle.svg</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image10.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c4 c2"></span></p><p class="c0"><span class="c4 c2">The bottom left corner is green, the bottom right corner is blue, and the top corner is red. Each point in the triangle is a blend of these three colors. The barycentric coordinates represent the components of the color at a certain point in the triangle, which is directly proportional to the distance between the point and the three corners.</span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c6 c2 c5"></span></p><p class="c0"><span class="c2 c5 c11">svg/basic/test7.svg</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 456.00px;"><img alt="" src="images/image4.png" style="width: 624.00px; height: 456.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c4 c2"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c4 c2"></span></p><p class="c0"><span class="c4 c9">Part 5</span></p><p class="c0 c3"><span class="c4 c2"></span></p><p class="c0"><span class="c4 c2">Pixel sampling is the process of determining the color of a pixel on a rendered image based on the colors of texels (texture elements) from a texture map. When performing texture mapping, the texture coordinates associated with each vertex of a primitive (such as a triangle) are interpolated across the surface of the primitive, and then these interpolated coordinates are used to sample texels from the texture map. The sampled texels are then used to determine the color of each pixel within the primitive on the rendered image.</span></p><p class="c0 c3"><span class="c4 c2"></span></p><p class="c0"><span class="c4 c2">In nearest-pixel sampling, the texel nearest to the interpolated texture coordinates is selected for sampling. In bilinear sampling, instead of selecting just one texel, a weighted average of the colors of the four texels surrounding the interpolated texture coordinates is calculated.</span></p><p class="c0 c3"><span class="c4 c2"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c6 c2 c5"></span></p><p class="c0"><span class="c6 c2 c5">svg/texmap/test1.svg</span></p><p class="c0"><span class="c2 c5">nearest sampling at 1 sample per pixel</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 530.50px; height: 381.72px;"><img alt="" src="images/image2.png" style="width: 530.50px; height: 381.72px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c6 c2 c5">svg/texmap/test1.svg</span></p><p class="c0"><span class="c2 c5">bilinear sampling at 1 sample per pixel</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 527.50px; height: 379.59px;"><img alt="" src="images/image6.png" style="width: 527.50px; height: 379.59px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c0"><span class="c6 c2 c5">svg/texmap/test1.svg</span></p><p class="c0"><span class="c2 c5">nearest sampling at 16 samples per pixel</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 479.72px; height: 345.18px;"><img alt="" src="images/image13.png" style="width: 479.72px; height: 345.18px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c6 c2 c5">svg/texmap/test1.svg</span></p><p class="c0"><span class="c2 c5">bilinear sampling at 16 samples per pixel</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 481.33px; height: 346.34px;"><img alt="" src="images/image11.png" style="width: 481.33px; height: 346.34px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c4 c2"></span></p><p class="c0"><span class="c4 c9">Explanation:</span></p><p class="c0"><span class="c4 c2">The difference between two methods is exceptionally obvious when we have less samples per pixels, when using fewer samples per pixel, each texel covers a larger area of the screen, leading to more pronounced differences between nearest and bilinear sampling methods. Nearest sampling simply selects the color of the nearest texel, resulting in sharp edges and pixelation, especially when the texture is magnified or displayed at oblique angles. On the other hand, bilinear sampling blends the colors of neighboring texels, resulting in smoother transitions and reduced pixelation. </span></p><p class="c0 c3"><span class="c4 c2"></span></p><p class="c0"><span class="c2 c10">When there are more details in the image or more color variations in the image at less samples per pixel, there tends to be larger differences between the two methods. As nearest sampling creates a sharper image by selecting color directly from nearest pixel and the image created by biliear sampling is smoother as it takes input from more pixels and interpolated the inputs. &nbsp;</span></p><p class="c0 c3"><span class="c2 c4"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c4 c2"></span></p><p class="c0"><span class="c4 c9">Part 6</span></p><p class="c0 c3"><span class="c4 c2"></span></p><p class="c0"><span class="c4 c2">Level sampling in texture mapping refers to the process of selecting the appropriate level of detail from a mipmapped texture based on the texture coordinates and the level of detail sampling method specified. Mipmapping is a technique used to optimize texture mapping by pre-generating multiple versions of a texture at different resolutions, called mipmaps. Each mipmap level represents the same texture image but at progressively lower resolutions.</span></p><p class="c0 c3"><span class="c4 c2"></span></p><p class="c0"><span class="c4 c2">We implemented the get_level method by calculating based on the rate of change of texture coordinates with respect to screen space. The maximum change in texture coordinates is used to determine the appropriate mipmap level, calculated using logarithmic scaling. And we also adjust the level according to whether we are doing &ldquo;L_ZERO&rdquo;, &ldquo;L_NEAREST&rdquo;, or &ldquo;L_LINEAR&rdquo;. </span></p><p class="c0 c3"><span class="c4 c2"></span></p><p class="c0"><span class="c4 c2">In rasterizer.cpp, we initialized the vertices of the triangle using the provided vertex coordinates, and these vertices are represented as 3D vectors in the screen space. We ensures that the vertices of the triangle are in the correct order by checking their orientation using cross products. </span></p><p class="c0"><span class="c4 c2">We calculated Barycentric coordinates for each pixel within the triangle, and these coordinates determine the interpolation weights of the texture coordinates at each pixel. Using the barycentric coordinates, the texture coordinates are interpolated across the triangle for each pixel. For each pixel, texture samples are taken based on the interpolated texture coordinates. And we did this by calculating the texture coordinates and their gradients, and constructing a SampleParams object containing the texture sampling parameters, and calling the texture.sample function with the SampleParams object to obtain the color value from the texture. Finally we use the obtained color value from the texture to filled into the corresponding pixel in the framebuffer. </span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c6 c2 c5"></span></p><p class="c0"><span class="c6 c2 c5">svg/texmap/custom.svg</span></p><p class="c0"><span class="c2 c10">L_ZERO and P_NEAREST</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image7.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c0"><span class="c2 c5 c6">svg/texmap/custom.svg</span></p><p class="c0"><span class="c2 c5">L_ZERO and P_LINEAR</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image3.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c0"><span class="c6 c2 c5">svg/texmap/custom.svg</span></p><p class="c0"><span class="c2 c5">L_NEAREST and P_NEAREST</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image12.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c0"><span class="c6 c2 c5">svg/texmap/custom.svg</span></p><p class="c0"><span class="c2 c5">L_NEAREST and P_LINEAR</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image15.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></body></html>